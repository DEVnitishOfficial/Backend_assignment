[
  {
    "title": "Two Sum",
    "difficulty": "Easy",
    "topics": ["Array", "Hash Table"],
    "companies": ["Google", "Microsoft"],
    "hints": ["Use a hash map to store previously seen numbers."],
    "statement": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ]
  },
  {
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "topics": ["Stack", "String"],
    "companies": ["Amazon", "Adobe"],
    "hints": ["Use a stack to keep track of opening brackets."],
    "statement": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
    "examples": [
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "All brackets are closed in correct order."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "Mismatched parentheses."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists only of parentheses characters '()[]{}'."
    ]
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "topics": ["Array", "Dynamic Programming"],
    "companies": ["Apple", "Facebook"],
    "hints": ["Track the minimum price so far and calculate profit at each step."],
    "statement": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy and a single day to sell. Return the maximum profit you can achieve.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price=1) and sell on day 5 (price=6)."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ]
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "topics": ["Hash Table", "String", "Sliding Window"],
    "companies": ["Google", "Amazon", "Bloomberg"],
    "hints": ["Use sliding window to track characters."],
    "statement": "Given a string s, find the length of the longest substring without repeating characters.",
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with length 3."
      }
    ],
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols and spaces."
    ]
  },
  {
    "title": "Merge Intervals",
    "difficulty": "Medium",
    "topics": ["Array", "Sorting"],
    "companies": ["Microsoft", "Uber"],
    "hints": ["Sort intervals first by start time."],
    "statement": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals and return an array of the non-overlapping intervals.",
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, so merge them."
      }
    ],
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= start_i <= end_i <= 10^4"
    ]
  },
  {
    "title": "Binary Tree Level Order Traversal",
    "difficulty": "Medium",
    "topics": ["Tree", "Breadth-First Search"],
    "companies": ["Amazon", "Microsoft", "Google"],
    "hints": ["Use a queue to perform BFS."],
    "statement": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": "First level has [3], second has [9,20], third has [15,7]."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ]
  }
]
